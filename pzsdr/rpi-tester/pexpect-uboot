#!/usr/bin/env python3
#
# This script is used to coordinate saving the AD936x output clock frequency
# and user-inputted MAC address to the u-boot environment as well as writing
# various data to flash memory after successful picozed SDR test runs.
#
# Note that it uses python3 and requires pexpect, pyserial, and picocom to
# be installed.
#
# It also currently assumes the use of a Prologix GPIB-USB controller as well
# as an Agilent 53131A frequency counter used to measure the output clock
# frequency from the AD936x.

import errno
import glob
import os
import sys
import time
import re

import pexpect
import serial

# manufacturer MAC address prefix (ADI's by default)
MAC_ADDR_OUI = '0005F780'

# model name added to u-boot env and written to device tree
MODEL_Z7035 = 'ADRV9361-Z7035'
MODEL_Z7020 = 'ADRV9364-Z7020'

# serial device paths
UART = '/dev/serial/by-id/*Silicon_Labs_CP2103_USB_to_UART_Bridge_Controller_0001*'
FC = '/dev/serial/by-id/*HAMEG_Instruments_HO820*'

class SerialError(Exception):
    """Generic exception for serial device errors."""

class UBootError(Exception):
    """Generic exception for errors when communicating with u-boot."""


def get_freq(fc_dev):
    """Get current AD936x output clock frequency.

    Returns: frequency in HZ
    """
    try:
        s = serial.Serial(fc_dev)
    except OSError as e:
        if e.errno == errno.ENOENT:
            raise SerialError("serial device doesn't exist: %s" % fc_dev)
        raise SerialError('issue opening serial device: %s: %s' % (fc_dev, e))

    s.baudrate = 9600
    s.bytesize = serial.EIGHTBITS
    s.parity = serial.PARITY_NONE
    s.stopbits = serial.STOPBITS_ONE
    s.timeout = 2
    s.xonxoff = False
    s.rtscts = False
    s.dsrdtr = False
    s.writeTimeout = 0

    # encode unicode strings to be written into byte strings
    def _write(string):
        s.write(string.encode())

    if not s.isOpen():
        try:
            s.open()
        except Exception as e:
            raise SerialError(e)

    s.flushInput()
    s.flushOutput()

    # Read Identifiaction String
    _write('IDN\r\n')
    device_id = s.readline().strip()
    if not device_id:
        raise SerialError('error communicating with Frequency Counter device')

    # we're using channel A
    _write('FRA\r\n')
    # Set CHA to high impedance mode
    _write('OAH\r\n')
    # Set CHA to AC coupling
    _write('ACA\r\n')
    # request the current measured frequency
    nb_tries = 5
    while nb_tries:
        _write('XMT\r\n')
        freq = s.readline().strip()
        if b'MHz' in freq:
              break
        nb_tries -=1
    s.close()
    if not freq:
        raise SerialError('error querying counter for current frequency')

    freq = int(float(re.sub(b"[^0-9]", b"", freq)))

    # We expect a value close to 40 MHz, error out if it's more than 5 kHz off.
    expected_freq = 40000000
    if abs(freq - expected_freq) > 5000:
        raise SerialError(
            'Measured frequency too far away from expected frequency (40 MHz): %d Hz' % (freq,))
    print(freq)
    return freq

def get_som_model():
    """Read SOM model from user for device.

    Requires that user input the device specific portion.

    Returns: model string.
    """
    model = None
    while model is None:
        read = input('Enter "1" for SOM1 and "2" for SOM2: ')
        # validate input
        try:
           read_model = int(read)
        except ValueError:
           print('Please enter just one digit. "1" for SOM1 and "2" for SOM2.')
           continue
        if read_model == 1:
               model = MODEL_Z7020
        elif read_model == 2:
               model = MODEL_Z7035
        else:
               print('Please enter just one digit. "1" for SOM1 and "2" for SOM2.')
               continue
           
    return model

def get_mac_addr():
    """Get MAC address for device.

    Requires that user input the device specific portion.

    Returns: MAC address string in xx:xx:xx:xx:xx:xx format.
    """
    suffix = None
    while suffix is None:
        orig_suffix = input('Enter the remaining 4 character MAC address suffix (e.g. fa34): ')
        # remove all character spacers
        strip_spacers = orig_suffix.maketrans({x: None for x in ':-.'})
        suffix = orig_suffix.translate(strip_spacers)

        # check if it's a valid hex string
        invalid_hex = False
        try:
            int(suffix, 16)
        except ValueError:
            invalid_hex = True

        if len(suffix) != 4 or invalid_hex:
            print('Invalid MAC address suffix: %s' % orig_suffix)
            suffix = None

    mac_addr = MAC_ADDR_OUI + suffix
    mac_addr = '%s%s:%s%s:%s%s:%s%s:%s%s:%s%s' % tuple(mac_addr.lower())
    return mac_addr


def spawn_picocom(serial_dev):
    try:
        p = pexpect.spawnu('picocom --nolock -b 115200 %s' % (serial_dev,))
    except pexpect.exceptions.ExceptionPexpect:
        raise SerialError('picocom is missing, please install it')

    # send output to the terminal and don't reprint input commands
    p.logfile = sys.stdout
    p.setecho(False)

    return p


def uboot_expect():
    """Pexpect loop to run after the tests complete successfully."""

    spawned = False
    timed_out = False
    warning = False

    # output string specifying that the u-boot command line is ready
    prompt = 'zynq-uboot> '

    def _extract_bytes(l):
        """Extract the size of the file read from u-boot output.

        Returns the file size in bytes.
        """
        # input should consist of a list of strings similar to ['123456', 'bytes', 'read']
        if len(l) != 3 or l[1] != 'bytes' or l[2] != 'read':
            raise UBootError('received unexpected reply when reading file')

        try:
            return int(l[0])
        except ValueError:
            raise UBootError('received unexpected bytes value when reading file')

    def _flash_file(filepath, offset, size, erase=False, timeout=30, mem_location=0x1000000):
        """Erase and write a file to a QSPI flash partition.

        Parameters:
            filepath: path to file to write to partition
            offset: partition offset
            size: partition size
            erase: whether to erase the flash location before writing
            timeout: time to wait while erasing partition (to avoid pexpect timeouts)
            mem_location: external memory location to load file to and from
        """
        # erase memory
        p.sendline('mw 0x%x 0x0 0x%x' % (mem_location, size))
        p.expect(prompt)

        # load file into memory
        p.sendline('fatload mmc 0 0x%x %s' % (mem_location, filepath))
        p.expect('.* bytes read')
        filesize = _extract_bytes(p.after.strip().split()[-3:])
        p.expect(prompt)

        if erase:
            # erase flash partition and write file into it
            p.sendline('sf update 0x%x 0x%x 0x%x' % (mem_location, offset, size))
            p.expect('.* bytes written, .* bytes skipped', timeout=timeout)
        else:
            # we assume flash chips ship pre-erased (as noted in the part's datasheet)
            p.sendline('sf write 0x%x 0x%x 0x%x' % (mem_location, offset, size))
            p.expect('SF: %d bytes @ 0x%x Written: OK' % (size, offset), timeout=timeout)

        p.expect(prompt)

    while 1:
        try:
            # determine UART and Frequency Counter usb serial device paths
            try:
                uart_dev = glob.glob(UART)[0]
                fc_dev = glob.glob(FC)[0]
            except IndexError:
                raise SerialError('UART and/or Frequency Counter serial device nodes missing, make sure cables are plugged in and devices are powered on')

            if not spawned:
                p = spawn_picocom(uart_dev)
                spawned = True
            if not timed_out:
                p.expect('Terminal ready')
                print('Waiting for u-boot output, please power on or reset the device')
            i = p.expect(['ALL TESTS PASSED', 'TESTS FAILED'], timeout=1800)
            if i == 1:
                p.expect('Hit any key')
                print('Tests failed, restarting loop...')
                continue
            p.expect(prompt)

            # run query to determine actual ad936x reference clock
            # frequency and save it to the u-boot environment
            try:
                freq = get_freq(fc_dev)
            except ValueError as e:
                print('\nError querying frequency counter: %s, restarting loop...' % (e,))
                continue
            p.sendline('setenv ad9361_ext_refclk <0x%x>' % (freq,))
            p.expect(prompt)
            print()
            MODEL = get_som_model()
            p.sendline('setenv model %s' % (MODEL,))
            p.expect(prompt)

            p.sendline('sf probe')
            p.expect('SF: Detected N25Q256A')
            p.expect(prompt)

            # write files to flash
            _flash_file('flash/BOOT.BIN', 0x0, 0xe0000)
            _flash_file('uImage', 0x100000, 0x500000)
            _flash_file('devicetree.dtb', 0x600000, 0x20000)
            _flash_file('flash/uramdisk.image.gz', 0x620000, 0xce0000, timeout=60)
            _flash_file('flash/system.bit', 0x1300000, 0xd00000, timeout=60)

            # set MAC address
            print()
            mac_addr = get_mac_addr()
            p.sendline('setenv ethaddr %s' % mac_addr)
            p.expect(prompt)
            p.sendline('saveenv')
            p.expect(prompt)
            print('\n\n############################################')
            print('Board ready for shipping')
            print('Power off and insert next module for testing')
            print('############################################')
            timed_out = False
        except pexpect.TIMEOUT:
            if not timed_out:
                print('\nTimed out waiting for u-boot output, restarting loop...')
            timed_out = True
            continue
        except KeyboardInterrupt:
            # restart the expect loop if the user hits Ctrl-C
            print('Got keyboard interrupt, restarting loop...')
            timed_out = True
            continue
        except pexpect.EOF as e:
            if spawned:
                print('\nSerial device closed, restarting loop...')
                spawned = False
            time.sleep(1)
            continue
        except SerialError as e:
            if not warning:
                print(e)
                warning = True
            time.sleep(1)
            continue
        except UBootError as e:
            print('\nError running U-Boot command: %s, restarting loop...' % e)
            time.sleep(1)
            continue
    p.close()

if __name__ == '__main__':
    while 1:
        try:
            uboot_expect()
        except KeyboardInterrupt:
            print()
            pass
        except UnicodeDecodeError:
            # we don't care about unicode decoding issues, e.g. if linux starts
            # booting and dumps odd characters into the output stream
            pass
